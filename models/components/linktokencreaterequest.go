// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
)

// LinkTokenCreateRequestLanguage - The language that Link should be displayed in.
type LinkTokenCreateRequestLanguage string

const (
	LinkTokenCreateRequestLanguageEn LinkTokenCreateRequestLanguage = "EN"
	LinkTokenCreateRequestLanguageEs LinkTokenCreateRequestLanguage = "ES"
	LinkTokenCreateRequestLanguageFr LinkTokenCreateRequestLanguage = "FR"
	LinkTokenCreateRequestLanguageDe LinkTokenCreateRequestLanguage = "DE"
	LinkTokenCreateRequestLanguageIt LinkTokenCreateRequestLanguage = "IT"
	LinkTokenCreateRequestLanguagePt LinkTokenCreateRequestLanguage = "PT"
	LinkTokenCreateRequestLanguageNl LinkTokenCreateRequestLanguage = "NL"
	LinkTokenCreateRequestLanguagePl LinkTokenCreateRequestLanguage = "PL"
	LinkTokenCreateRequestLanguageSv LinkTokenCreateRequestLanguage = "SV"
	LinkTokenCreateRequestLanguageDa LinkTokenCreateRequestLanguage = "DA"
	LinkTokenCreateRequestLanguageNo LinkTokenCreateRequestLanguage = "NO"
	LinkTokenCreateRequestLanguageEt LinkTokenCreateRequestLanguage = "ET"
	LinkTokenCreateRequestLanguageLt LinkTokenCreateRequestLanguage = "LT"
	LinkTokenCreateRequestLanguageLv LinkTokenCreateRequestLanguage = "LV"
	LinkTokenCreateRequestLanguageRo LinkTokenCreateRequestLanguage = "RO"
)

func (e LinkTokenCreateRequestLanguage) ToPointer() *LinkTokenCreateRequestLanguage {
	return &e
}
func (e *LinkTokenCreateRequestLanguage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EN":
		fallthrough
	case "ES":
		fallthrough
	case "FR":
		fallthrough
	case "DE":
		fallthrough
	case "IT":
		fallthrough
	case "PT":
		fallthrough
	case "NL":
		fallthrough
	case "PL":
		fallthrough
	case "SV":
		fallthrough
	case "DA":
		fallthrough
	case "NO":
		fallthrough
	case "ET":
		fallthrough
	case "LT":
		fallthrough
	case "LV":
		fallthrough
	case "RO":
		*e = LinkTokenCreateRequestLanguage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LinkTokenCreateRequestLanguage: %v", v)
	}
}

// LinkTokenCreateRequestBetaSourceStatus - To control which sources to be shown regarding their beta status
type LinkTokenCreateRequestBetaSourceStatus string

const (
	LinkTokenCreateRequestBetaSourceStatusLiveAndBeta LinkTokenCreateRequestBetaSourceStatus = "LiveAndBeta"
	LinkTokenCreateRequestBetaSourceStatusOnlyLive    LinkTokenCreateRequestBetaSourceStatus = "OnlyLive"
	LinkTokenCreateRequestBetaSourceStatusOnlyBeta    LinkTokenCreateRequestBetaSourceStatus = "OnlyBeta"
)

func (e LinkTokenCreateRequestBetaSourceStatus) ToPointer() *LinkTokenCreateRequestBetaSourceStatus {
	return &e
}
func (e *LinkTokenCreateRequestBetaSourceStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LiveAndBeta":
		fallthrough
	case "OnlyLive":
		fallthrough
	case "OnlyBeta":
		*e = LinkTokenCreateRequestBetaSourceStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LinkTokenCreateRequestBetaSourceStatus: %v", v)
	}
}

// Update - Used for launching Link in update or refresh mode
type Update struct {
	// The `access_token` associated with the existing Connection to update
	AccessToken string `json:"access_token"`
	// Set which mode you want to use between Update and Refresh.
	// Update mode will ask to enter the password, for updating it.
	// Refresh mode will re-use existing known credentials and will only let the user interact with the MFA step during sign-in.
	Mode LinkTokenCreateRequestUpdateModeEnum `json:"mode"`
}

func (u *Update) GetAccessToken() string {
	if u == nil {
		return ""
	}
	return u.AccessToken
}

func (u *Update) GetMode() LinkTokenCreateRequestUpdateModeEnum {
	if u == nil {
		return LinkTokenCreateRequestUpdateModeEnum("")
	}
	return u.Mode
}

// ParsingMethod - Choose the type of parsing needed for the connection
type ParsingMethod string

const (
	ParsingMethodPdfOnly            ParsingMethod = "PdfOnly"
	ParsingMethodBasic              ParsingMethod = "Basic"
	ParsingMethodFullSustainability ParsingMethod = "FullSustainability"
	ParsingMethodNone               ParsingMethod = "None"
)

func (e ParsingMethod) ToPointer() *ParsingMethod {
	return &e
}
func (e *ParsingMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PdfOnly":
		fallthrough
	case "Basic":
		fallthrough
	case "FullSustainability":
		fallthrough
	case "None":
		*e = ParsingMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ParsingMethod: %v", v)
	}
}

type LinkTokenCreateRequest struct {
	// The language that Link should be displayed in.
	Language *LinkTokenCreateRequestLanguage `json:"language,omitempty"`
	// Specify an array of Datadeck-supported country codes using the ISO-3166-1 alpha-2 country code standard. Sources from all listed countries will be shown.
	Countries []string `json:"countries,omitempty"`
	// The name of the customization from Deck dashboard to be applied to this Widget session. If not specified, the default customization will be used. Values provided in this payload override the dashboard customization settings.
	CustomizationName *string `json:"customization_name,omitempty"`
	// You can specify exactly the sources to be shown in Link by providing a list of source ids.
	SourceIds []string `json:"source_ids,omitempty"`
	// You can limit the sources to be shown in Link by specifying which source types to be shown in Link.
	SourceTypes []string `json:"source_types,omitempty"`
	// To control which sources to be shown regarding their beta status
	BetaSourceStatus *LinkTokenCreateRequestBetaSourceStatus `json:"beta_source_status,omitempty"`
	// Used for launching Link in update or refresh mode
	Update *Update `json:"update,omitempty"`
	// The webhook URL to receive update events.
	WebhookURL *string `json:"webhook_url,omitempty"`
	// If true, the Link session will automatically refresh the data.
	AutoRefresh *bool `json:"auto_refresh,omitempty"`
	// Choose the type of parsing needed for the connection
	ParsingMethod *ParsingMethod `json:"parsing_method,omitempty"`
	// Specifies whether to collect only the latest invoice data or all available invoices
	LatestInvoiceOnly *bool `json:"latest_invoice_only,omitempty"`
}

func (l *LinkTokenCreateRequest) GetLanguage() *LinkTokenCreateRequestLanguage {
	if l == nil {
		return nil
	}
	return l.Language
}

func (l *LinkTokenCreateRequest) GetCountries() []string {
	if l == nil {
		return nil
	}
	return l.Countries
}

func (l *LinkTokenCreateRequest) GetCustomizationName() *string {
	if l == nil {
		return nil
	}
	return l.CustomizationName
}

func (l *LinkTokenCreateRequest) GetSourceIds() []string {
	if l == nil {
		return nil
	}
	return l.SourceIds
}

func (l *LinkTokenCreateRequest) GetSourceTypes() []string {
	if l == nil {
		return nil
	}
	return l.SourceTypes
}

func (l *LinkTokenCreateRequest) GetBetaSourceStatus() *LinkTokenCreateRequestBetaSourceStatus {
	if l == nil {
		return nil
	}
	return l.BetaSourceStatus
}

func (l *LinkTokenCreateRequest) GetUpdate() *Update {
	if l == nil {
		return nil
	}
	return l.Update
}

func (l *LinkTokenCreateRequest) GetWebhookURL() *string {
	if l == nil {
		return nil
	}
	return l.WebhookURL
}

func (l *LinkTokenCreateRequest) GetAutoRefresh() *bool {
	if l == nil {
		return nil
	}
	return l.AutoRefresh
}

func (l *LinkTokenCreateRequest) GetParsingMethod() *ParsingMethod {
	if l == nil {
		return nil
	}
	return l.ParsingMethod
}

func (l *LinkTokenCreateRequest) GetLatestInvoiceOnly() *bool {
	if l == nil {
		return nil
	}
	return l.LatestInvoiceOnly
}
