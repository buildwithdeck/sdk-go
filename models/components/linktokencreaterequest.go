// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
)

// LinkTokenCreateRequestLanguage - The language that Link should be displayed in.
type LinkTokenCreateRequestLanguage string

const (
	LinkTokenCreateRequestLanguageEn LinkTokenCreateRequestLanguage = "EN"
	LinkTokenCreateRequestLanguageEs LinkTokenCreateRequestLanguage = "ES"
	LinkTokenCreateRequestLanguageFr LinkTokenCreateRequestLanguage = "FR"
	LinkTokenCreateRequestLanguageDe LinkTokenCreateRequestLanguage = "DE"
	LinkTokenCreateRequestLanguageIt LinkTokenCreateRequestLanguage = "IT"
	LinkTokenCreateRequestLanguagePt LinkTokenCreateRequestLanguage = "PT"
	LinkTokenCreateRequestLanguageNl LinkTokenCreateRequestLanguage = "NL"
	LinkTokenCreateRequestLanguagePl LinkTokenCreateRequestLanguage = "PL"
	LinkTokenCreateRequestLanguageSv LinkTokenCreateRequestLanguage = "SV"
	LinkTokenCreateRequestLanguageDa LinkTokenCreateRequestLanguage = "DA"
	LinkTokenCreateRequestLanguageNo LinkTokenCreateRequestLanguage = "NO"
	LinkTokenCreateRequestLanguageEt LinkTokenCreateRequestLanguage = "ET"
	LinkTokenCreateRequestLanguageLt LinkTokenCreateRequestLanguage = "LT"
	LinkTokenCreateRequestLanguageLv LinkTokenCreateRequestLanguage = "LV"
	LinkTokenCreateRequestLanguageRo LinkTokenCreateRequestLanguage = "RO"
)

func (e LinkTokenCreateRequestLanguage) ToPointer() *LinkTokenCreateRequestLanguage {
	return &e
}
func (e *LinkTokenCreateRequestLanguage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EN":
		fallthrough
	case "ES":
		fallthrough
	case "FR":
		fallthrough
	case "DE":
		fallthrough
	case "IT":
		fallthrough
	case "PT":
		fallthrough
	case "NL":
		fallthrough
	case "PL":
		fallthrough
	case "SV":
		fallthrough
	case "DA":
		fallthrough
	case "NO":
		fallthrough
	case "ET":
		fallthrough
	case "LT":
		fallthrough
	case "LV":
		fallthrough
	case "RO":
		*e = LinkTokenCreateRequestLanguage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LinkTokenCreateRequestLanguage: %v", v)
	}
}

// LinkTokenCreateRequestBetaSourceStatus - To control which sources to be shown regarding their beta status
type LinkTokenCreateRequestBetaSourceStatus string

const (
	LinkTokenCreateRequestBetaSourceStatusLiveAndBeta LinkTokenCreateRequestBetaSourceStatus = "LiveAndBeta"
	LinkTokenCreateRequestBetaSourceStatusOnlyLive    LinkTokenCreateRequestBetaSourceStatus = "OnlyLive"
	LinkTokenCreateRequestBetaSourceStatusOnlyBeta    LinkTokenCreateRequestBetaSourceStatus = "OnlyBeta"
)

func (e LinkTokenCreateRequestBetaSourceStatus) ToPointer() *LinkTokenCreateRequestBetaSourceStatus {
	return &e
}
func (e *LinkTokenCreateRequestBetaSourceStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LiveAndBeta":
		fallthrough
	case "OnlyLive":
		fallthrough
	case "OnlyBeta":
		*e = LinkTokenCreateRequestBetaSourceStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LinkTokenCreateRequestBetaSourceStatus: %v", v)
	}
}

// Update - Used for launching Link in update or refresh mode
type Update struct {
	// The `access_token` associated with the existing Connection to update
	AccessToken string `json:"access_token"`
	// Set which mode you want to use between Update and Refresh.
	// Update mode will ask to enter the password, for updating it.
	// Refresh mode will re-use existing known credentials and will only let the user interact with the MFA step during sign-in.
	Mode LinkTokenCreateRequestUpdateModeEnum `json:"mode"`
}

func (o *Update) GetAccessToken() string {
	if o == nil {
		return ""
	}
	return o.AccessToken
}

func (o *Update) GetMode() LinkTokenCreateRequestUpdateModeEnum {
	if o == nil {
		return LinkTokenCreateRequestUpdateModeEnum("")
	}
	return o.Mode
}

// ParsingMethod - Choose the type of parsing needed for the connection
type ParsingMethod string

const (
	ParsingMethodPdfOnly            ParsingMethod = "PdfOnly"
	ParsingMethodBasic              ParsingMethod = "Basic"
	ParsingMethodFullSustainability ParsingMethod = "FullSustainability"
	ParsingMethodNone               ParsingMethod = "None"
)

func (e ParsingMethod) ToPointer() *ParsingMethod {
	return &e
}
func (e *ParsingMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PdfOnly":
		fallthrough
	case "Basic":
		fallthrough
	case "FullSustainability":
		fallthrough
	case "None":
		*e = ParsingMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ParsingMethod: %v", v)
	}
}

type LinkTokenCreateRequest struct {
	// The language that Link should be displayed in.
	Language *LinkTokenCreateRequestLanguage `json:"language,omitempty"`
	// Specify an array of Datadeck-supported country codes using the ISO-3166-1 alpha-2 country code standard. Sources from all listed countries will be shown.
	Countries []string `json:"countries,omitempty"`
	// You can specify exactly the sources to be shown in Link by providing a list of source ids.
	SourceIds []string `json:"source_ids,omitempty"`
	// You can limit the sources to be shown in Link by specifying which source types to be shown in Link.
	SourceTypes []string `json:"source_types,omitempty"`
	// To control which sources to be shown regarding their beta status
	BetaSourceStatus *LinkTokenCreateRequestBetaSourceStatus `json:"beta_source_status,omitempty"`
	// Used for launching Link in update or refresh mode
	Update *Update `json:"update,omitempty"`
	// The webhook URL to receive update events.
	WebhookURL *string `json:"webhook_url,omitempty"`
	// If true, the Link session will automatically refresh the data.
	AutoRefresh *bool `json:"auto_refresh,omitempty"`
	// Choose the type of parsing needed for the connection
	ParsingMethod *ParsingMethod `json:"parsing_method,omitempty"`
	// Specifies whether to collect only the latest invoice data or all available invoices
	LatestInvoiceOnly *bool `json:"latest_invoice_only,omitempty"`
}

func (o *LinkTokenCreateRequest) GetLanguage() *LinkTokenCreateRequestLanguage {
	if o == nil {
		return nil
	}
	return o.Language
}

func (o *LinkTokenCreateRequest) GetCountries() []string {
	if o == nil {
		return nil
	}
	return o.Countries
}

func (o *LinkTokenCreateRequest) GetSourceIds() []string {
	if o == nil {
		return nil
	}
	return o.SourceIds
}

func (o *LinkTokenCreateRequest) GetSourceTypes() []string {
	if o == nil {
		return nil
	}
	return o.SourceTypes
}

func (o *LinkTokenCreateRequest) GetBetaSourceStatus() *LinkTokenCreateRequestBetaSourceStatus {
	if o == nil {
		return nil
	}
	return o.BetaSourceStatus
}

func (o *LinkTokenCreateRequest) GetUpdate() *Update {
	if o == nil {
		return nil
	}
	return o.Update
}

func (o *LinkTokenCreateRequest) GetWebhookURL() *string {
	if o == nil {
		return nil
	}
	return o.WebhookURL
}

func (o *LinkTokenCreateRequest) GetAutoRefresh() *bool {
	if o == nil {
		return nil
	}
	return o.AutoRefresh
}

func (o *LinkTokenCreateRequest) GetParsingMethod() *ParsingMethod {
	if o == nil {
		return nil
	}
	return o.ParsingMethod
}

func (o *LinkTokenCreateRequest) GetLatestInvoiceOnly() *bool {
	if o == nil {
		return nil
	}
	return o.LatestInvoiceOnly
}
